<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>ðŸ§­ BoatNavigator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>

  <style>
    :root{
      --bg: #ffffff;
      --panel: #ffffff;
      --text: #1f2937;
      --muted: #6b7280;
      --border: #e5e7eb;
      --accent: #0ea5e9;       /* cyan-500 */
      --accent-600: #0284c7;
      --shadow: 0 8px 24px rgba(0,0,0,.12);
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
    }
    @media (prefers-color-scheme: dark){
      :root{
        --bg: #0b1220;
        --panel: #0f172a;       /* slate-900 */
        --text: #e5e7eb;
        --muted: #94a3b8;
        --border: #1f2937;
        --accent: #22d3ee;      /* cyan-400 */
        --accent-600: #06b6d4;
        --shadow: 0 10px 28px rgba(0,0,0,.45);
      }
    }

    html, body, #map { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: var(--sans); }
    a { color: var(--accent); }

    /* Panel */
    .panel{
      position:absolute; top:12px; right:12px; width: min(480px, 92vw);
      background: var(--panel); border: 1px solid var(--border); border-radius: 12px;
      box-shadow: var(--shadow); z-index:1000; overflow: hidden;
    }
    .panel__header{
      display:flex; align-items:center; justify-content:space-between;
      padding:12px 14px; border-bottom:1px solid var(--border);
      background: linear-gradient(180deg, rgba(2,132,199,.08), transparent);
    }
    .title{ font-weight:700; letter-spacing:.2px; }
    .subtitle{ color:var(--muted); font-size:12px; }

    .panel__body{ padding:12px 14px 10px; display:grid; gap:10px; }
    .section-title{ font-weight:600; margin-top:4px; color: var(--text); }

    /* Fields */
    .row{ display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center; }
    .grid-2{ display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
    .grid-3{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px; }
    label{ font-size:12px; color: var(--muted); display:block; margin-bottom:4px; }
    input[type="datetime-local"], input[type="number"], input[type="text"], input[type="range"]{
      width:100%; box-sizing:border-box; padding:8px 10px; border-radius:8px;
      border:1px solid var(--border); background:transparent; color:var(--text);
      outline:none;
    }
    input[type="range"]{ padding:0; }

    .checks{ display:flex; flex-wrap:wrap; gap:10px; color: var(--text); }
    .checks label{ display:flex; align-items:center; gap:6px; color:var(--text); font-size:13px; }

    /* Buttons */
    .actions{ display:flex; gap:8px; flex-wrap:wrap; }
    .btn{
      appearance:none; border:none; border-radius:10px; padding:10px 12px; font-weight:600;
      background: var(--accent); color:#001016; cursor:pointer; transition: transform .04s ease, opacity .2s;
    }
    .btn:hover{ transform: translateY(-1px); }
    .btn:active{ transform: translateY(0); }
    .btn.secondary{
      background: transparent; color: var(--text); border:1px solid var(--border);
    }

    /* Output block */
    .out{
      font-family: var(--mono); font-size:12px; white-space:pre-wrap;
      border:1px dashed var(--border); border-radius:8px; padding:8px; color: var(--text);
      background: rgba(14,165,233,.06);
    }

    /* Segments table */
    #segContainer { max-height: 260px; overflow: auto; border: 1px solid var(--border); border-radius: 10px; }
    .seg-table { border-collapse: collapse; width: 100%; font-size: 12px; }
    .seg-table th, .seg-table td { border-bottom: 1px solid var(--border); padding: 6px 8px; text-align: center; }
    .seg-table thead th { position: sticky; top: 0; background: rgba(2,132,199,.10); backdrop-filter: blur(2px); }
    .seg-table tbody tr:nth-child(odd){ background: rgba(148,163,184,.06); }
    .seg-table tbody tr:hover { background: rgba(34,211,238,.12); cursor: pointer; }

    /* Small helpers */
    .hr{ height:1px; background: var(--border); margin: 4px 0 2px; }
    .muted{ color: var(--muted); }
    .inline{ display:flex; align-items:center; gap:8px; }
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="panel">
    <div class="panel__header">
      <div>
        <div class="title">ðŸ§­ BoatNavigator</div>
        <div class="subtitle">Planifiez, estimez, exportez</div>
      </div>
    </div>

    <div class="panel__body">

      <div class="grid-1">
        <div class="row">
          <div>
            <label>DÃ©part</label>
            <input id="start" type="datetime-local"/>
          </div>
          <div class="inline muted" style="justify-content:flex-end; font-size:12px;">
            <span id="wxTime" class="muted"></span>
          </div>
        </div>
      </div>

      <div class="grid-2">
        <div>
          <label>Vitesse base (kn)</label>
          <input id="v0" type="number" value="10" step="0.1">
        </div>
        <div>
          <label>Conso moyenne (L/h)</label>
          <input id="lph" type="number" value="5" step="0.1">
        </div>
      </div>

      <div class="checks">
        <label><input type="checkbox" id="useWind" checked> Vent</label>
        <label><input type="checkbox" id="useWaves" checked> Vagues</label>
        <label><input type="checkbox" id="compare"> Comparer (avec vs sans)</label>
      </div>

      <div class="actions">
        <button id="calc" class="btn">Calculer conso</button>
        <button id="exportGPX" class="btn secondary">Export GPX</button>
        <button id="exportPDF" class="btn secondary">Export PDF</button>
      </div>

      <div class="out" id="out">Distance: â€” km
Temps: â€” h
Conso: â€” L</div>

      <div class="hr"></div>
      <div class="section-title">Segments</div>
      <div id="segContainer">
        <table class="seg-table" id="segTable">
          <thead>
            <tr>
              <th>#</th><th>Cap (Â°)</th><th>Dist</th><th>Vitesse (kn)</th>
              <th>Î”t</th><th>DÃ©but</th><th>Fin</th><th>Conso (L)</th>
              <th>Vent</th><th>Houle</th>
            </tr>
          </thead>
          <tbody><!-- rows dynamisÃ©es --></tbody>
        </table>
      </div>

      <div class="hr"></div>
      <div class="section-title">MÃ©tÃ©o</div>
      <div class="inline" style="gap:12px;">
        <label class="inline"><input type="checkbox" id="wxToggle"> Pluie (RainViewer)</label>
        <input id="wxSlider" type="range" min="0" max="0" step="1" value="0" disabled style="flex:1">
      </div>

    </div>
  </div>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<script>
const map = L.map('map').setView([47.6, -2.9], 10);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
  {attribution:'Â© OpenStreetMap'}).addTo(map);

// Dessin de la route
const drawnItems = new L.FeatureGroup().addTo(map);
const drawControl = new L.Control.Draw({
  draw: {
    polyline: { shapeOptions:{weight:4} },
    polygon: false, rectangle: false, circle: false, marker: false, circlemarker:false
  }, edit: { featureGroup: drawnItems }
});
map.addControl(drawControl);

let routeLine = null;
map.on(L.Draw.Event.CREATED, e => {
  if (routeLine) drawnItems.removeLayer(routeLine);
  routeLine = e.layer;
  drawnItems.addLayer(routeLine);
});

function bboxOfLine(line){
  const coords = line.getLatLngs();
  let minx= 180, maxx=-180, miny= 90, maxy=-90;
  coords.forEach(p=>{
    minx = Math.min(minx, p.lng); maxx = Math.max(maxx, p.lng);
    miny = Math.min(miny, p.lat); maxy = Math.max(maxy, p.lat);
  });
  return [minx,miny,maxx,maxy];
}

document.getElementById('calc').onclick = async ()=>{
  if(!routeLine){ alert('Tracez une route (polyline)'); return; }

  const startVal = document.getElementById('start').value || new Date().toISOString().slice(0,16);
  const payload = {
    start_iso: new Date(startVal).toISOString(),
    base_speed_kn: parseFloat(document.getElementById('v0').value),
    lph: parseFloat(document.getElementById('lph').value),
    model: { Uref:10, Href:1, alpha:0.08, beta:0.10, gamma:0.15, delta:0.10 },
    use_wind: document.getElementById('useWind').checked,
    use_waves: document.getElementById('useWaves').checked,
    mode: document.getElementById('compare').checked ? 'both' : 'corrected',
    route: routeLine.toGeoJSON().geometry
  };

  const r = await fetch('/api/consumption', {
    method:'POST', headers:{'Content-Type':'application/json'},
    body: JSON.stringify(payload)
  });
  const res = await r.json();

   // Affiche les totaux
  const base = res.corrected || res.baseline || res;
  document.getElementById('out').textContent =
    `Distance: ${base.distance_km.toFixed(1)} km
Temps: ${base.time_h.toFixed(2)} h
Conso: ${base.liters.toFixed(1)} L`;

  // Construit la liste des segments
  if(base.segments && base.segments.length){
    buildSegmentsTable(base.segments, payload.start_iso);
  }else{
    document.querySelector('#segTable tbody').innerHTML =
      `<tr><td colspan="8" style="text-align:center;color:#777">Aucun segment</td></tr>`;
  }

  function fmt(s){ return `Distance: ${(s.distance_km).toFixed(1)} km
Temps: ${s.time_h.toFixed(2)} h
Conso: ${s.liters.toFixed(1)} L`; }

  let txt = '';
  if(res.baseline && res.corrected){
    txt = `â€” Baseline (sans vent/vagues) â€”
${fmt(res.baseline)}

â€” CorrigÃ© (options actuelles) â€”
${fmt(res.corrected)}

Î” (corrigÃ© - baseline)
Temps: ${res.delta.time_h>=0?'+':''}${res.delta.time_h.toFixed(2)} h
Conso: ${res.delta.liters>=0?'+':''}${res.delta.liters.toFixed(1)} L`;
  } else if(res.corrected){
    txt = fmt(res.corrected);
  } else if(res.baseline){
    txt = fmt(res.baseline);
  }
  document.getElementById('out').textContent = txt;
};

  // ====== Helpers format ======
  function fmtNM(m){ return (m/1852).toFixed(2) + ' NM'; }
  function fmtH(h){
    const s = Math.round(h*3600), hh = Math.floor(s/3600), mm = Math.floor((s%3600)/60);
    return `${hh}h${String(mm).padStart(2,'0')}`;
  }
  function fmtHHMM(d){ return d.toLocaleTimeString('fr-FR', {hour:'2-digit', minute:'2-digit'}); }
  function fmtWind(met){
    if (!met) return 'â€”';
    const sp = met.wind_speed_10m;
    const di = met.wind_direction_10m;
    if (sp == null || di == null) return 'â€”';
    return `${Number(sp).toFixed(1)} kn / ${Math.round(di)}Â°`;
  }
  function fmtSwell(met){
    if (!met) return 'â€”';
    // on prend dâ€™abord la houle si dispo, sinon la vague totale
    const h = (met.swell_wave_height != null) ? met.swell_wave_height : met.wave_height;
    const d = (met.swell_wave_direction != null) ? met.swell_wave_direction : met.wave_direction;
    if (h == null || d == null) return 'â€”';
    return `${Number(h).toFixed(1)} m / ${Math.round(d)}Â°`;
  }

  // ====== Surbrillance de segment sur la carte ======
  const segHighlight = L.polyline([], {color:'#00BCD4', weight:6, opacity:0.7}).addTo(map);
  function clearHighlight(){ segHighlight.setLatLngs([]); }
  function highlightSegment(i){
    if(!routeLine) return;
    const pts = routeLine.getLatLngs();
    if(i<0 || i>=pts.length-1) return;
    segHighlight.setLatLngs([pts[i], pts[i+1]]).bringToFront();
  }
  function zoomToSegment(i){
    if(!routeLine) return;
    const pts = routeLine.getLatLngs();
    if(i<0 || i>=pts.length-1) return;
    const b = L.latLngBounds([pts[i], pts[i+1]]);
    map.fitBounds(b.pad(0.5));
    highlightSegment(i);
  }

  // ====== Remplissage du tableau des segments ======
  function buildSegmentsTable(segments, startIso){
    const tbody = document.querySelector('#segTable tbody');
    tbody.innerHTML = '';
    let t = new Date(startIso);
    segments.forEach((s, idx)=>{
      const dt_h = s.eta_h;
      const tEnd = new Date(t.getTime() + dt_h*3600*1000);

      const tr = document.createElement('tr');
      tr.dataset.index = String(idx);
      tr.innerHTML = `
        <td>${idx+1}</td>
        <td>${Math.round(s.bearing_deg)}</td>
        <td>${fmtNM(s.distance_m)}</td>
        <td>${s.speed_kn.toFixed(1)}</td>
        <td>${fmtH(dt_h)}</td>
        <td>${fmtHHMM(t)}</td>
        <td>${fmtHHMM(tEnd)}</td>
        <td>${s.liters.toFixed(2)}</td>
        <td>${fmtWind(s.met)}</td>
        <td>${fmtSwell(s.met)}</td>
      `;
      // interactions
      tr.addEventListener('mouseenter', ()=> highlightSegment(idx));
      tr.addEventListener('mouseleave', ()=> clearHighlight());
      tr.addEventListener('click', ()=> zoomToSegment(idx));

      tbody.appendChild(tr);
      t = tEnd; // avance l'horloge pour le prochain segment
    });
  }


async function downloadBlob(url, payload, filename){
  const r = await fetch(url, {
    method:'POST', headers:{'Content-Type':'application/json'},
    body: JSON.stringify(payload)
  });
  if(!r.ok){ alert('Export: erreur serveur'); return; }
  const blob = await r.blob();
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a); a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 2000);
}

function buildPayload(){
  if(!routeLine){ alert('Tracez une route'); return null; }
  const startVal = document.getElementById('start').value || new Date().toISOString().slice(0,16);
  return {
    start_iso: new Date(startVal).toISOString(),
    base_speed_kn: parseFloat(document.getElementById('v0').value),
    lph: parseFloat(document.getElementById('lph').value),
    model: { Uref:10, Href:1, alpha:0.08, beta:0.10, gamma:0.15, delta:0.10 },
    use_wind: document.getElementById('useWind') ? document.getElementById('useWind').checked : true,
    use_waves: document.getElementById('useWaves') ? document.getElementById('useWaves').checked : true,
    route: routeLine.toGeoJSON().geometry
  };
}

document.getElementById('exportGPX').onclick = async ()=>{
  const payload = buildPayload(); if(!payload) return;
  await downloadBlob('/export/gpx', payload, 'navigation.gpx');
};
document.getElementById('exportPDF').onclick = async ()=>{
  const payload = buildPayload(); if(!payload) return;
  await downloadBlob('/export/pdf', payload, 'navigation.pdf');
};

  // ====== Radar pluie (RainViewer) â€” prÃ©vision nowcast + slider temps
    const wxToggle = document.getElementById('wxToggle');
    const wxSlider = document.getElementById('wxSlider');
    const wxTime   = document.getElementById('wxTime');

    let rvFrames = [];           // frames disponibles (objets API RainViewer)
    let rvLayers = [];           // Leaflet TileLayers cacheÃ©s par index
    let rvIndex  = 0;            // index courant
    let rvLoaded = false;        // avons-nous chargÃ© les frames ?

    function formatLocalTime(ts){ // ts en secondes
      const d = new Date(ts * 1000);
      // Affiche en heure locale courte (ex: 14:30)
      return d.toLocaleTimeString('fr-FR', {hour: '2-digit', minute: '2-digit'});
    }

    async function loadRainViewer(){
      // API publique : frames passÃ©es & nowcast
      const url = 'https://api.rainviewer.com/public/weather-maps.json';
      const r = await fetch(url);
      if (!r.ok) throw new Error('RainViewer indisponible');
      const j = await r.json();

      // Combine passÃ© et futur pour plus de frames
      let frames = [];
      if (j.radar && j.radar.past) frames = frames.concat(j.radar.past);
      if (j.radar && j.radar.nowcast) frames = frames.concat(j.radar.nowcast);

        
      rvFrames = frames;
      rvLayers = new Array(frames.length);
      rvIndex = frames.length ? frames.length - 1 : 0; // par dÃ©faut la plus rÃ©cente
      wxSlider.min = 0;
      wxSlider.max = Math.max(0, frames.length - 1);
      wxSlider.value = rvIndex;
      wxSlider.disabled = frames.length === 0;
      wxTime.textContent = frames.length ? formatLocalTime(frames[rvIndex].time) : 'â€”';
      rvLoaded = true;
    }

    function buildTileLayerFor(frame){
      // frame.path fourni par lâ€™API. Exemple:
      // https://tilecache.rainviewer.com + frame.path + '/256/{z}/{x}/{y}/2/1_1.png'
      const url = `https://tilecache.rainviewer.com${frame.path}/256/{z}/{x}/{y}/2/1_1.png`;
      return L.tileLayer(url, {
        tileSize: 256,
        opacity: 0.6,
        zIndex: 400,
        attribution: '&copy; RainViewer'
      });
    }

    function showRainLayerAt(index){
      if (!rvFrames.length) return;

      // retire layer courant si diffÃ©rent
      for (let i=0;i<rvLayers.length;i++){
        if (rvLayers[i] && map.hasLayer(rvLayers[i])) map.removeLayer(rvLayers[i]);
      }

      rvIndex = Math.min(Math.max(index, 0), rvFrames.length - 1);
      if (!rvLayers[rvIndex]) rvLayers[rvIndex] = buildTileLayerFor(rvFrames[rvIndex]);
      rvLayers[rvIndex].addTo(map);
      wxTime.textContent = formatLocalTime(rvFrames[rvIndex].time);
    }

    wxToggle.addEventListener('change', async () => {
      if (wxToggle.checked){
        try{
          if (!rvLoaded) await loadRainViewer();
          showRainLayerAt(parseInt(wxSlider.value, 10) || rvIndex);
        } catch (e){
          console.warn(e);
          wxToggle.checked = false;
          alert("Impossible de charger la carte pluie pour le moment.");
        }
      } else {
        // retire tous les layers
        rvLayers.forEach(Lyr => { if (Lyr && map.hasLayer(Lyr)) map.removeLayer(Lyr); });
      }
    });

    wxSlider.addEventListener('input', () => {
      if (!rvLoaded || !wxToggle.checked) return;
      const idx = parseInt(wxSlider.value, 10) || 0;
      showRainLayerAt(idx);
    });

</script>
</body>
</html>
